README - Εργασία 3
Ηλίας Καλαμάτας || 1115201400053
Εαρινό εξάμηνο - Ακαδημαϊκού έτους "2020-2021"

Η εργασία δεν ειναι χωρισμένη σε υποφακέλους. Όλα τα απαραίτητα αρχεία βρίσκονται στον ίδιο φάκελο.

** Μεταγλώτισση και Εκτέλεση **
1. Η μεταγλώττιση γίνεται με makefile και υπάρχουν οι εξής επιλογές:
	α) make all (δημιουργία/ανανέωση travelMonitorClient + monitorServer)
	β) make travelMonitorClient
	γ) make monitorServer
	δ) make clean (καθαρισμός εκτελέσιμων και .o αρχείων)
2. Ενδεικτική Εκτέλεση: ./travelMonitorClient -m 2 -b 250 -c 4 -s 1000 -i ./CountryLogs -t 4
(Προσοχή: έχει θεωρηθεί δεδομένο ότι ο socketBuffer, που θα χρησιμοποιηθεί, είναι τουλάχιστον 200bytes)

** Διαχωρισμός Αρχείων Εφαρμογής App **
1. InputHandler (.cpp + .h) --> Περιέχει κλάση με απαραίτητες μεθόδους για τη διαχείρηση εισόδου της εφαρμογής + Συναρτήσεις για σύγκριση Dates
2. HashUtil (.cpp + .h) --> Περιέχει συναρτήσεις, που υλοποιούν Hashing Algorithms
3. CitizenRecords (.cpp + .h) --> Περιέχει κλάσεις σχετικές με την αποθήκευση δεδομένων + Δημιουργία πίνακα με ορίσματα για την execvp
4. BloomFilter (.cpp + .h) --> Κλάσεις για την υλοποίηση του Bloom Filter και της λίστας των Bloom Filters 
5. SkipList (.cpp + .h) --> Κλάσεις για την υλοποίηση της Skip List και της λίστας των Skip Lists
7. TravelRecords (.cpp + .h) --> Κλάσεις για την αποθήκευση πληροφοριών σχετικά με τα Travel Requests
8. Server (.cpp) --> Η εφαρμογή, που τρέχει το κάθε child process
6. mainClient (.cpp) --> Η κύρια εφαρμογή

** Γενικές 'Παραδοχές' και Επεξηγήσεις **
- Για την εφαρμογή:
>Οι παρατηρήσεις που ακολουθούν αφορούν κυρίως παραδοχές, καθώς σημεία του κώδικα γίνονται κατανοητά με την ύπαρξη σχολιασμού.
	* Έλεγχος αριθμού και ορθότητα ορισμάτων
	* Χρήση 1 socket ανά process (ορισμός IP μηχανήματος χρησιμοποιώντας gethostname() + gethostbyname(), ορισμός port πρώτου socket με define και κάθε επόμενου socket είναι port+1)
	* Δημιουργία πίνακα ορισμάτων και αποστολή με execvp σε κάθε child process
	* Το parent thread λειτουργεί ως producer και δημιουργεί consumer-time threads
	* Υλοποίηση κυκλικού buffer ως struct ίδιας λογικής με αυτόν των διαφανειών του μαθήματος
	* Συγχρονισμός με χρήση ενός mutex και δύο condition variables (ένα προς producer για προσθήκη αρχείων στον κυκλικό buffer και ένα προς consumers για ενημέρωση ύπαρξης νέου αρχείου σε αυτόν)
	* Όταν το child process είναι έτοιμο αποστέλει 1 στο parent πάνω από το socket
	* Στα child procress: Χρήση sig_flag για αναγνώριση σήματος και της αντίστοιχης ενέργειας. Δηλαδή, 1 σε περίπτωση τερματισμού, 2 σε περίπτωση που έχει προστεθεί κάποιο νέο αρχείο προς ανάγνωση και 3 σε περίπτωση που πρέπει να απαντήσει σε αιτήματα (υλοποίηση με SIGUSR2). Στην περίπτωση του 3, τότε το parent process ακολουθεί με αποστολή 0 για αποστολή απάντησης σε /travelRequest ή 1 για αποστολή απάντησης σε /searchVaccinationStatus
	* Όλες οι υπόλοιπες λειτουργικότητες είναι ίδιες με την εργασία 2
	
>Σημείωση: Για την ημερομηνία ο έλεγχος δεν είναι 100% αυστηρός αλλά δεχόμαστε τα εξής:
	* Χωρίζεται με παύλες (ενημέρωση στο /help)
	* Πρέπει να ξεκινάει με αριθμό και να τελειώνει με 4 αριθμούς
	* Ελέγχεται η ύπαρξη παύλας μετά τη μέρα και πριν τη χρονολογία
	* Δεχόμαστε ότι εφόσον ισχύουν τα παραπάνω λογικά θα πρέπει να έχει δοθεί σωστά
